head(times)
library("ggplot2")
x <- as.numeric(times$n_procs)
y <- as.numeric(times$time_nonblocking)
#plot times for non blocking implementation
plot(x, times$time_nonblocking, type='l', xlab="N procs", ylab="Time", col=5, lwd=2, ylim=c(0,1.5*10^(-4)))
#close the png file
dev.off()
#plot times for non blocking implementation
plot(x, times$time_nonblocking, type='l', xlab="N procs", ylab="Time", col=5, lwd=2, ylim=c(0,1.5*10^(-4)))
points(x, times$time_nonblocking,pch=16,col=5)
#plot times for blocking implementation
lines(x, times$time_blocking, type='l', xlab="N procs", ylab="Time", col=6, lwd=2)
points(x, times$time_blocking,pch=16,col=6)
abline(v = 24, lty = 2, lwd=1.5)
text(22, 0.0, "n_procs=24", pos = 4, srt=90)
#plot theoretical model for non blocking implementation
y1 <- x[1:24]*(2*2*(10^(-6))/12000 + 0.68*(10^(-6)))
y2 <- x[25:47]*(2*2*(10^(-6))/12200 + 1.23*(10^(-6)))
lines(x, c(y1,y2), type='l', col="#0f95a6", lty = 2,lwd=2)
#plot theoretical model for blocking implementation
y1 <- 2*y1
y2 <- 2*y2
lines(x, c(y1,y2), type='l', col="#a30f94", lty = 2,lwd=2)
abline(v = 24, lty = 2, lwd=1.5)
text(22, 0.0, "n_procs=24", pos = 4, srt=90)
#plot theoretical model for non blocking implementation
y1 <- x[1:24]*(2*2*(10^(-6))/20000 + 0.68*(10^(-6)))
y2 <- x[25:47]*(2*2*(10^(-6))/12200 + 1.23*(10^(-6)))
lines(x, c(y1,y2), type='l', col="#0f95a6", lty = 2,lwd=2)
#plot theoretical model for blocking implementation
y1 <- 2*y1
y2 <- 2*y2
lines(x, c(y1,y2), type='l', col="#a30f94", lty = 2,lwd=2)
#plot times for non blocking implementation
plot(x, times$time_nonblocking, type='l', xlab="N procs", ylab="Time", col=5, lwd=2, ylim=c(0,1.5*10^(-4)))
points(x, times$time_nonblocking,pch=16,col=5)
#plot times for blocking implementation
lines(x, times$time_blocking, type='l', xlab="N procs", ylab="Time", col=6, lwd=2)
points(x, times$time_blocking,pch=16,col=6)
abline(v = 24, lty = 2, lwd=1.5)
text(22, 0.0, "n_procs=24", pos = 4, srt=90)
#plot theoretical model for non blocking implementation
y1 <- x[1:24]*(2*2*(10^(-6))/20000 + 0.68*(10^(-6)))
y2 <- x[25:47]*(2*2*(10^(-6))/12200 + 1.23*(10^(-6)))
lines(x, c(y1,y2), type='l', col="#0f95a6", lty = 2,lwd=2)
#plot theoretical model for blocking implementation
y1 <- 2*y1
y2 <- 2*y2
lines(x, c(y1,y2), type='l', col="#a30f94", lty = 2,lwd=2)
# read csv assignment 1,section 1, part 2
library(ggplot2)
library(gridExtra)
library(grid)
setwd("~/DSSC/hpc_assignment1/section1/matrix")
#set table theme
color_df <- data.frame(color = c("#ffffff", "#bfdedd"), stringsAsFactors = FALSE)
my_table_theme <- ttheme_default(core=list(bg_params = list(fill = color_df$color[1:2], col=NA)), colhead =list(bg_params=list(fill ="#8bb0af")))
#times to sum matrices
times <- data.frame(read.csv("3D_matrix.csv"))
colnames(times) <- c("Matrix dims", "Topology", "Time taken", "Comp time")
grid.table(times, rows=NULL, theme = my_table_theme)
#save table as png
png("3D_matrix_results.png")
grid.table(times, rows=NULL,theme = my_table_theme)
dev.off()
# compute theoretical times
B <- 10000 # ~ estimated latency without the use of the cache
lambda <- 24*0.68*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- 2*(2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
# compute theoretical times
B <- 8000 # ~ estimated latency without the use of the cache
lambda <- 24*0.68*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- 2*(2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
comm_time <- times$`Time taken` - times$`Comp time`
comm_time
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
# compute theoretical times
B <- 75000 # ~ estimated latency without the use of the cache
lambda <- 24*0.68*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
comm_time <- times$`Time taken` - times$`Comp time`
# compute theoretical times
B <- 7500 # ~ estimated latency without the use of the cache
lambda <- 24*0.68*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
lambda <- 0.68*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
lambda <- 0.40*(10^(-6))
# size of matrix (2 matrices) multiplied by 8 (size of double)
size <- (2400*100*100)*8*(10^(-6))
T <- 3*(size/B + lambda) # ~ 0.1152
comm_time <- times$`Time taken` - times$`Comp time`
2400*100*100*8
(2400*100*100)*8*(10^(-6))
# read csv assignment 1, section 2
library(ggplot2)
library(RColorBrewer)
library(patchwork)
library(data.table)
library(ggpubr)
setwd("~/DSSC/hpc_assignment1/section2")
col_legend <- brewer.pal(n=8, name="Dark2")
##############
plot_times <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
model <-lm(t.usec.[1:26] ~ X.bytes[1:26], df)
lambda <-  model$coef[1]
B <- model$coef[2]
print(file)
print(coef(model))
print(paste0("bandwith: ", 1/coef(model)[2]))
times <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
# fit
# geom_line(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
# geom_point(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
geom_point(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
geom_line(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
labs(x = "Message size (bytes)", y = "Time") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
if(!"t.usec.comp."  %in% colnames(df1)){
df1$t.usec.comp.[1:24] <- round(loess(t.usec. ~ X.bytes, df)$fitted, 4)
fwrite(df1, paste0("csv/",file))
}
return(times)
}
plot_bandwidth <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
#bandwidth
bandwidth <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical")) +
geom_point(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical"))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
# fit
#geom_point(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df,degree=1)$fitted, color="fit model", group=1))+
#geom_line(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df, degree=1)$fitted, color="fit model", group=1))+
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
# geom_line(linetype = "dashed",data = df, aes(x = as.factor(X.bytes), y = 12000, color="th. bandwidth", group=1)) +
labs(x = "Message size (bytes)", y = "Bandwidth") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
if(!"Mbytes.sec.comp."  %in% colnames(df1)){
df1$Mbytes.sec.comp.[1:24] <- round(df$X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), 4)
fwrite(df1, paste0("csv/",file))
}
return(bandwidth)
}
plot_nshm <- function(core, socket, node, type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
node_times <- plot_times(node)
core_times + socket_times + node_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
node_bandwidth <- plot_bandwidth(node)
core_bandwidth + socket_bandwidth + node_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
plot_shm <- function(core, socket,type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
core_times + socket_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
core_bandwidth + socket_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
#openmpi - cpu
##############
#ucx
plot_nshm("core_ucx.csv", "socket_ucx.csv", "node_ucx.csv", "ucx_openmpi_cpu")
#tcp
plot_nshm("core_tcp.csv", "socket_tcp.csv", "node_tcp.csv", "tcp_openmpi_cpu")
#tcp
plot_nshm("core_tcp.csv", "socket_tcp.csv", "node_tcp.csv", "tcp_openmpi_cpu")
#vader
plot_shm("core_vader.csv", "socket_vader.csv", "vader_openmpi_cpu")
#openmpi - gpu
##############
#ucx
plot_nshm("core_ucx_gpu.csv", "socket_ucx_gpu.csv", "node_ucx_gpu.csv", "ucx_openmpi_gpu")
#tcp
plot_nshm("core_tcp_gpu.csv", "socket_tcp_gpu.csv", "node_tcp_gpu.csv", "tcp_openmpi_gpu")
#vader
plot_shm("core_vader_gpu.csv", "socket_vader_gpu.csv", "vader_openmpi_gpu")
#intel - cpu
##############
#ucx
plot_nshm("intel_core_ucx.csv", "intel_socket_ucx.csv", "intel_node_ucx.csv", "ucx_intel_cpu")
#tcp
plot_nshm("intel_core_tcp.csv", "intel_socket_tcp.csv", "intel_node_tcp.csv", "tcp_intel_cpu")
#vader
plot_shm("intel_core_shm.csv", "intel_socket_shm.csv","shm_intel_cpu")
#intel - gpu
##############
#ucx
plot_nshm("intel_core_ucx_gpu.csv", "intel_socket_ucx_gpu.csv", "intel_node_ucx_gpu.csv", "ucx_intel_gpu")
#tcp
plot_nshm("intel_core_tcp_gpu.csv", "intel_socket_tcp_gpu.csv", "intel_node_tcp_gpu.csv", "tcp_intel_gpu")
#vader
plot_shm("intel_core_shm_gpu.csv", "intel_socket_shm_gpu.csv", "shm_intel_gpu")
## nocache
plot_shm("nocache_core_ucx.csv", "nocache_socket_ucx.csv", "nocache_ucx_openmpi_cpu")
setwd("~/DSSC/hpc_assignment1/section2")
col_legend <- brewer.pal(n=8, name="Dark2")
##############
plot_times <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
# model <-lm(t.usec.[1:26] ~ X.bytes[1:26], df1)
# lambda <-  model$coef[1]
# B <- model$coef[2]
times <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
# fit
# geom_line(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
# geom_point(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
geom_point(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
geom_line(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
labs(x = "Message size (bytes)", y = "Time") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
if(!"t.usec.comp."  %in% colnames(df1)){
df1$t.usec.comp.[1:24] <- round(loess(t.usec. ~ X.bytes, df)$fitted, 4)
fwrite(df1, paste0("csv/",file))
}
return(times)
}
plot_bandwidth <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
#bandwidth
bandwidth <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical")) +
geom_point(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical"))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
# fit
#geom_point(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df,degree=1)$fitted, color="fit model", group=1))+
#geom_line(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df, degree=1)$fitted, color="fit model", group=1))+
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
# geom_line(linetype = "dashed",data = df, aes(x = as.factor(X.bytes), y = 12000, color="th. bandwidth", group=1)) +
labs(x = "Message size (bytes)", y = "Bandwidth") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
if(!"Mbytes.sec.comp."  %in% colnames(df1)){
df1$Mbytes.sec.comp.[1:24] <- round(df$X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), 4)
fwrite(df1, paste0("csv/",file))
}
return(bandwidth)
}
plot_nshm <- function(core, socket, node, type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
node_times <- plot_times(node)
core_times + socket_times + node_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
node_bandwidth <- plot_bandwidth(node)
core_bandwidth + socket_bandwidth + node_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
plot_shm <- function(core, socket,type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
core_times + socket_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
core_bandwidth + socket_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
#openmpi - cpu
##############
#ucx
plot_nshm("core_ucx.csv", "socket_ucx.csv", "node_ucx.csv", "ucx_openmpi_cpu")
#tcp
plot_nshm("core_tcp.csv", "socket_tcp.csv", "node_tcp.csv", "tcp_openmpi_cpu")
#vader
plot_shm("core_vader.csv", "socket_vader.csv", "vader_openmpi_cpu")
setwd("~/DSSC/hpc_assignment1/section2")
col_legend <- brewer.pal(n=8, name="Dark2")
##############
plot_times <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
# model <-lm(t.usec.[1:26] ~ X.bytes[1:26], df1)
# lambda <-  model$coef[1]
# B <- model$coef[2]
times <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
# fit
# geom_line(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
# geom_point(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
geom_point(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
geom_line(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
labs(x = "Message size (bytes)", y = "Time") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
# if(!"t.usec.comp."  %in% colnames(df1)){
df$t.usec.comp.[1:24] <- round(loess(t.usec. ~ X.bytes, df)$fitted, 4)
fwrite(df, paste0("csv/",file))
#  }
return(times)
}
plot_bandwidth <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
#bandwidth
bandwidth <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical")) +
geom_point(data = df, aes(x = as.factor(X.bytes), group = 2, y = Mbytes.sec, color="empirical"))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(min(t.usec.) + X.bytes/max(Mbytes.sec)), color="comm. model", group=1)) +
# fit
#geom_point(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df,degree=1)$fitted, color="fit model", group=1))+
#geom_line(aes(as.factor(df$X.bytes), loess(Mbytes.sec ~ X.bytes, df, degree=1)$fitted, color="fit model", group=1))+
geom_line(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), color="fit model", group=1)) +
# geom_line(linetype = "dashed",data = df, aes(x = as.factor(X.bytes), y = 12000, color="th. bandwidth", group=1)) +
labs(x = "Message size (bytes)", y = "Bandwidth") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
#  if(!"Mbytes.sec.comp."  %in% colnames(df1)){
df$Mbytes.sec.comp.[1:24] <- round(df$X.bytes/(loess(t.usec. ~ X.bytes, df)$fitted), 4)
fwrite(df, paste0("csv/",file))
#  }
return(bandwidth)
}
plot_nshm <- function(core, socket, node, type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
node_times <- plot_times(node)
core_times + socket_times + node_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
node_bandwidth <- plot_bandwidth(node)
core_bandwidth + socket_bandwidth + node_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
plot_shm <- function(core, socket,type) {
core_times <- plot_times(core)
socket_times <- plot_times(socket)
core_times + socket_times +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/times_", type, ".png"), width = 20, height = 8, dpi = 150)
core_bandwidth <- plot_bandwidth(core)
socket_bandwidth <- plot_bandwidth(socket)
core_bandwidth + socket_bandwidth +
plot_annotation(title =  gsub('_', ' ', type)) &  theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0( "images/bandwidth_", type, ".png"), width = 20, height = 8, dpi = 150)
}
#openmpi - cpu
##############
#ucx
plot_nshm("core_ucx.csv", "socket_ucx.csv", "node_ucx.csv", "ucx_openmpi_cpu")
#tcp
plot_nshm("core_tcp.csv", "socket_tcp.csv", "node_tcp.csv", "tcp_openmpi_cpu")
#vader
plot_shm("core_vader.csv", "socket_vader.csv", "vader_openmpi_cpu")
## nocache
plot_shm("nocache_core_ucx.csv", "nocache_socket_ucx.csv", "nocache_ucx_openmpi_cpu")
library(RColorBrewer)
library(patchwork)
library(data.table)
library(ggpubr)
setwd("~/DSSC/hpc_assignment1/section2")
col_legend <- brewer.pal(n=8, name="Dark2")
##############
plot_times <- function(file) {
df1 <- data.frame(read.csv(paste0("csv/",file)))
if(startsWith(file, "intel"))
file =  substring(file, 7)
df <- df1[1:24,]
# model <-lm(t.usec.[1:26] ~ X.bytes[1:26], df1)
# lambda <-  model$coef[1]
# B <- model$coef[2]
times <- ggplot() +
# core ucx
geom_line(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = t.usec., color="empirical", group = 1))  +
# theoretical
geom_line(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
geom_point(data = df, aes(x = as.factor(X.bytes), y = min(t.usec.) + X.bytes/max(Mbytes.sec), color="comm. model", group=1)) +
# fit
# geom_line(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
# geom_point(data = df, aes(x = as.factor(X.bytes), y = lambda + X.bytes*B, color="fit lm model", group=1)) +
geom_point(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
geom_line(aes(as.factor(df$X.bytes), loess(t.usec. ~ X.bytes, df)$fitted, color="fit model", group=1))+
labs(x = "Message size (bytes)", y = "Time") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank()) +
scale_colour_manual(values = c("empirical" = "#2bacbd", "comm. model" = "#cf5e25", "fit model" = "#297504")) +
labs(title = sub("\\_.*", "", file))
# if(!"t.usec.comp."  %in% colnames(df1)){
df$t.usec.comp.[1:24] <- round(loess(t.usec. ~ X.bytes, df)$fitted, 4)
fwrite(df, paste0("csv/",file))
#  }
return(times)
}
d1 <- data.frame(read.csv(paste0("csv/","nocache_core_ucx.csv")))
d1 <- data.frame(read.csv(paste0("csv/","nocache_socket_ucx.csv")))
d1 <- data.frame(read.csv(paste0("csv/","nocache_socket_ucx.csv")))
## nocache
plot_shm("nocache_core_ucx.csv", "nocache_socket_ucx.csv", "nocache_ucx_openmpi_cpu")
chart.Correlation(trees)
library("PerformanceAnalytics")
head(trees)
pairs(trees)
chart.Correlation(trees)
gam.1 <- gam(Volume ~ s(Height), family=Gamma(link=log), data=trees)
# As an example, consider the simple dataset trees, where we have measurements
# of the girth, height and volume of timber in 31 felled black cherry trees.
# Note that girth is the diameter of the tree (in inches) measured at 4 ft 6
# in above the ground. First of all, we use the pairs plot for checking possible
# correlations between the three variables.
library("mgcv")
gam.1 <- gam(Volume ~ s(Height), family=Gamma(link=log), data=trees)
summary(gam.1)
qchisq(0.95,1)
1-pchisq(970,59)
1-pchisq(940,58)
1-pchisq(540,58)
1-pchisq(1540,58)
1-pchisq(77540,58)
pchisq(1331.6,3)
pchisq(26,1)
1-pchisq(26,1)
